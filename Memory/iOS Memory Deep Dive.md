# iOS Memory Deep Dive

## Why reduce memory

- 앱 동작이 빨라질 뿐만 아니라, 사용자 경험이 좋아진다. 시스템이 더 좋은 성능을 발휘할 수 있게 된다.
- 현재 앱과, 다른 앱에 메모리에 오래동안 유지될 수 있다.

## Memory footprint

### Pages

다량의 객체를 힙에 저장할 수 있는 메모리 페이지는 시스템에 의해 생성된다. 어떤 객체는 다량의 페이지에 나눠져 저장될 수 있다.  보통 16KB 크기이며 clean 혹은 dirty 한 상태를 갖는다. 앱의 메모리 사용량은 실제로 페이지의 개수와 크기를 곱한 값이다. 

### Clean and dirty pages

clean 과 dirty 페이지의 예를 들기 위해, 2만개의 정수 배열을 할당했다고 가정한다. 시스템은 6개의 페이지를 제공한다. 할당할 당시에 이 페이지들은 clean한 상태이다. 하지만, 데이터 버퍼에 값을 쓸때, 해당 페이지는 dirty 상태가 된다. 값이 쓰여지지 않은 페이지는 여전히 clean한 상태를 유지한다.

### Memory mapped files

디스크에 있지만 메모리로부터 로드된 파일을 말한다. (가상 메모리에 있는 파일의 내용을 포함한다. 파일과 메모리의 매핑을 통해 메모리에서 읽고 쓸 수 있게 된다.) 만약, read-only 파일을 사용한다면 관련 페이지는 항상 clean한 상태일 것이다. 커널은 데이터가 언제 디스크에서 램으로 들어오고 나가는지를 관리한다.

JPEG이 이를 설명하는데 좋은 예시이다. 50KB 크기의 JPEG가 있고, 메모리에 매핑이 되면 4개의 페이지가 사용될 것이다. 네번째 페이지는 완전히 꽉차지 않고, 다른 것에 의해 사용될 공간이 남게된다. 꽉찬 3개의 페이지는 시스템에 의해 언제든지 제거될 수가 있다. 

### Typical app memory profile

메모리 프로파일은 dirty, compressed, clean 한 상태의 메모리 영역을 가지고 있다. 앱의 footprint라고 하면, Clean 메모리는 포함되지 않고, dirty와 compressed 영역만을 말한다. 모든 앱에는 footprint 제한이 있다. 대부분의 앱은 높은 제한을 가지고 있지만, 장치에 따라 이 제한은 변할 수 있다. 앱 extension(siri, push notification)은 더 낮은 제한을 가지고 있기 때문에, 주의할 필요가 있다. footprint를 초과하게 되면 EXC RESOURCE EXCEPTION 예외를 받게 될 것이다.

### Clean memory

clean 메모리는 페이지 아웃이 가능한 데이터이다. Memory-mapped file이 이것이며, 이미지, 데이터 블랍, 학습 모델 혹은 framework 등에 해당한다. 모든 framework는 DATA CONST 섹션이 있다. 보통 clean한 상태이지만 swizzling 같은 runtime shenanigans이 발생하면 언제든 dirty상태가 될 수 있다. 

### Dirty memory

dirty 메모리는 앱에 의해 쓰여진 모든 메모리를 말한다. malloc으로 할당된 객체이며, 문자열, 배열 등이 해당된다. 디코딩된 이미지 버퍼일 수도 있고, framework일 수도 있다. framework는 데이터 섹션과 데이터 dirty 섹션이 있다. 

### Frameworks

우리가 연결한 framework는 메모리와 dirty 메모리를 사용한다. 하지만, 우리가 정의한 framework를 가지고 있다면, 싱글턴과 전역 생성자는 그들이 사용하는 dirty 메모리 양을 줄이기 위한 좋은 방법이 된다. 왜냐하면 싱글턴은 생성된 이후에는 항상 메모리에 존재하며, 생성자는 framework가 연결되거나 클래스가 로드될 때마다 동작하기 때문이다.

### Compressed memory

iOS는 전통적인 디스크 스왑 시스템을 가지고 있지 않는 대신에, 메모리 compressor를 사용한다. 메모리 컴프레서는 접근되지 않은 페이지를  압축하여, 더 많은 공간을 만들어 낸다. 접근시에는 컴프레서가 압축을 풀며 메모리가 읽혀질 수 있도록 한다. 예를 들어, 캐싱을 위해 세개의 페이지를 사용하는 딕셔너리를 가지고 있다고 하자. 잠시동안 이 메모리에 접근하지 않고, 시스템은 메모리가 필요한 상황이라면, 그 메모리를 하나의 페이지로 압축한다. 두개의 페이지 여유분이 생긴 것이다. 나중에 접근할 때에는 다시 압축이 해제된다.

### Memory warnings

메모리 경고의 원인이 항상 앱은 아니다. 낮은 메모리 장치를 갖고 있을 수도 있고, 메모리 경고를 유발하는 전화를 할 수도 있다. 컴프레서는 메모리 해제를 복잡하게 만들 수 있다. 압축된 것이 무엇이냐에 따라 전보다 더 많은 메모리를 사용하게 될 수도 있기 때문이다. 따라서 메모리 경고가 발생하면 캐싱을 하지 않거나 background 작업을 지연시키는 작업과 같은 정책 변화가 필요하다.

메모리 경고를 받게되면, 캐시에서 모든 객체를 지우는 결정을 하게 된다. 이때 이전 예제의 압축된 딕셔너리에 접근하기 때문에 압축이 해제되어 이전보다 더 많은 메모리를 사용하게 된다. 이후에 다른 작업을 하면서 다시 압축이 되겠지만, 이와같은 일반적인 메모리 경고 상황에 주의할 필요가 있다.

### Caching

캐시를 사용하면 CPU가 반복적인 작업을 수행하지 않도록 해줄 수 있지만, 너무 많이 사용하게 되면, 메모리를 소진하게 될 것이다. 따라서 메모리 컴프레서와 캐시 사이의 균형을 맞추는 것이 중요하다. 다른 주의점은 딕셔너리 대신에 NSCache의 사용은 캐시 객체를 저장하는데 thread-safe 하다는 점이다. 또한 NSCache가 메모리 할당하는 방식은 해제가능하므로 메모리 제한적인 환경에서 더욱 적합하다. 



## Tools for profiling footprint

### Xcode memory gauge

### Instruments

## Images

메모리 사용량은 파일 크기가 아닌 이미지의 크기(dimension)이다. 예를 들어, 2048 * 1536 크기의 590KB짜리 이미지가 있다. 이 이미지는 실제로 10MB의 메모리를 사용한다. 이는 2048 * 1536 에 픽셀당 4바이트를 곱한 값이다.

iOS에서 이미지 처리는 load, decode, render 단계를 갖는다. load 단계에서 압축된 590KB의 JPEG 파일을 메모리로 로드한다. Decode 단계에서는 압축을 해제하여 GPU가 읽을 수 있는 포맷으로 변경한다. 여기서 10MB로 늘어난다. 이후 render단계에서는 보여지게 될 것이다.

### Image-rendering formats

SRGB 포맷에 의해 픽셀당 4바이트를 갖게 된다. red, green, blue, alpha에 각각 1바이트가 사용된다. 다양한 색을 표현하기 위해서 wide format을 지원하여 각 요소에 2바이트씩 사용될 수도 있다. Luminance   and alpha 8 포맷도 있는데, grayscale과 alpha 값만 저장한다. Alpha 8 포맷도 있는데, 픽셀당 1바이트만 사용한다. SRGB에 비해 75% 작은 크기이다.

### Picking the right format

### Downsampling



## Optimizing when in background

## Demo















