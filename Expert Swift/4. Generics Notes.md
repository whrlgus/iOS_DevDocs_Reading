- 제네릭 함수는 함수명 다음에 위치하는 화살괄호에 타입 파라미터(type parameter)를 선언하게 된다. 
	- 이 타입 파라미터는 함수 시그니쳐(파라미터 타입, 반환 타입)에 사용되어야 한다.
- 제네릭 타입은 타입명 다음에 타입 파라미터를 선언한다.
	- 그 자체로는 타입이 아닌 청사진에 가깝다.
	- 컴파일러는 특수화(specialization)된 변형만을 실제 타입으로 인지한다.
	- `where` 절을 사용하여 제네릭 타입의 익스텐션에 제약을 가할 수 있으며, 익스텐션의 단일 메소드만에도 제약을 가할 수 있다.
- PAT(protocol with associated type) 에서 제네릭 타입은 프로토콜의 요구사항 중 하나로 있게 된다.
	- 이 또한 타입이 아니기 때문데, 제네릭 제약으로만 사용가능하다.
	- 타입 이레이져(type erasure) 방식을 사용하여, PATs의 배열을 선언하는 등 PATs를 정규타입으로 사용할 수 있다.
		- 타입 이레이져는 타입 정보가 없는 동일한 구조의 타입을 정의하여 대체하는 방식이다.
- 컴파일 시에 타입 파라미터는 제네릭 호출 시 사용한 구체 타입으로 대체된다.
	- 이 과정을 특수화(specialization) 이라고 한다.
- 추론가능한 경우에 함수 호출시 타입 파라미터는 생략 가능하다.
- 프로토콜은 구현체가 여러개인 반면, 제네릭은 동일한 구현체를 사용한다.
- 제네릭 제약(generic constraint)을 추가하여 사용 가능 범위를 제한할 수 있다.
- `self` 는 인스턴스 메소드에서 사용하면 인스턴스를 참조하게 되지만, 클래스 메소드나 정적 메소드에서는 현재 타입의 값을 의미한다.
- 현재 타입의 값인 `self` 와 같은 타입의 값을 들고 있는 타입은 메타타입(`타입명.Type`)이라고 부른다. 
- `Self` 는 구체 타입의 별칭(alias)이다.
	- 프로토콜에서 사용되더다도 항상 구체타입을 의미한다.
 