# 3. Protocols
이 챕터는 프로토콜이 어떻게 작용하는지와 깔끔하고, 오래 지속되며 리팩토링이 쉬운 API를 생산하기 위해 코드에 어떻게 활용할 수 있는 지에 대한 설명을 하게 된다.
프로토콜이 할 수 있는 모든 것을 상기한 다음에, 뒷단에서 어떻게 동작하는지 보게 될 것이다. 또한 프로토콜을 사용하는 공통적인 패턴을 배우고, 명심해야할 엣지 케이스 또한 학습할 것이다.

## 3.1 Getting started with protocols
프로토콜의 중요성을 이해하기 위해서 정적 타입 언어가 어떻게 동작하는지 확인해보자.
```swift
counter.increment(by: 10)
```

`counter` 는 `Counter` 클래스의 객체이고, 인스턴스 메소드인 `increment(by:)` 를 호출한다고 해보자. 이 인스턴스 메소드는 클래스 안에 있을 수도있고 작성하는 것을 까먹어서 없을 수도 있다. Objective-c와 같은 좀 더 동적인 언어에서는 이 코드를 실행하지만 아무것도 일어나지 않게된다. JavaScript와 같은 몇몇 동적언어에서는 코드를 실행하지만 `increment` 가 없다는 에러를 보여준다. 정적 타입 언어인 스위프트는 클래스에 해당 메소드가 있는지 확인한 다음에, 없다면 코드를 실행하지 않는다. 

컴파일러는 `counter` 의 타입이 `Counter` 인 것을 알고, 일치하는 메소드가 있는지 확인할 수 있기 때문에 메소드의 존재 여부를 알 수 있다. 그러나 컴파일러도 우리도 정확히 어떤 타입을 사용할 지 모를 경우가 있다. 만약 `Counter` 뿐만 아니라 `DoubleCounter`, `UserCounter` 을 위한 유사한 동작의 단일 함수를 정의하는 경우는 어떨까?

다음 메소드를 보자:

```swift
func incrementCounter(counters: [?]) {
	for counter in counters {
		counter.increment(by: 1)
	}
}
```

`counters` 의 타입은 무엇이어야 할까? 다른 타입에도 동작해야 하기 때문에 `[Counter]` 로 제한하는 것은 적절하지 않다. `[Any]` 를 사용을 시도할 수 있겠으나, 스위프트는 `Any` 의 인스턴스가 해당 메소드를 가지고 있는지 알 수 없기 때문에 에러가 발생한다. 여기서 필요한 것은 컴파일러에게 "`increment(by:)` 를 가진 모든 타입" 이라고 알려주는 방법이다. 바로 여기서 프로토콜이 사용된다.

프로토콜은 다음과 같을 것이다:

```Swift
protocol Incrementable {
	func increment(by: Int)
}
```

메소드 요구사항과 함께 프로토콜을 정의함으로써, 타입으로서 이 프로토콜을 사용하여, 이 메소드는 `Incrementable` 을 구현하는 모든 것을 입력으로 할 수 있다는 것을 알려줄 수 있다.

```swift
func incrementCounter(counters: [Incrementable]) {
	for counter in counters {
		counter.increment(by: 1)
	}
}
```

이 프로토콜의 실체(concrete) 구현체를 작성한다면, 스위프트는 `increment(by:)` 메소드를 선언했는지 검사할 것이다. 이 점으로, 스위프트 컴파일러는 `Incrementable` 의 모든 인스턴스에 함수를 동작시킬 수 있음을 보장할 수 있다.

### Hiding information
프로토콜은 다양한 타입을 ,그 정보는 숨긴 채, 동일한 상위 타입으로서 사용할 수 있도록 하는 타입 시스템의 도구이다. 예를 들어, 우리는 `a` 와 `b` 의 변을 가진 정사각형에서 `a == b` 가 참이란 것은 안다. 또한 정사각형은 직사각형임을 안다. `a == b` 라는 요구사항을 제외한다면, 정사각형을 직사각형으로 다룰 수 있고 면적을 계산하기 위한 하나의 방법만을 정의할 수 있다. 그렇게 된다면 두개의 구현체를 작성할 필요가 없는 것이다. 

이와 유사하게, 프로토콜은 직접 노출하는 것을 제외한, 클래스나 구조체의 모든 다른 멤버를 숨긴다. 이점이 동일한 장소에서 여러 타입을 사용할 수 있게 해준다.

### Encoding semantics
함수 시그니쳐에는 인코딩할 수 없는 것이 있다. 예를 들어, 배열을 정렬하고 싶다고 하자. 다른 정렬 알고리즘을 허용하기 위해, 정렬 메소드들과 함께 `Sorter` 프로토콜을 구현한다.

하지만, 많은 데이터가 있는 앱에서, 알고리즘은 빨리질 필요가 있게 된다. 그래서 `Sorter` 구현체들을 O(n) 이상으로 빠르게 해야 한다. 또는 안정된(stable) 정렬 알고리즘이 필요할 수도 있다. 이 모든 예제는 컴파일러가 검사할 수가 없다. 대신에 이러한 요구사항은 타입 명이나 문서에 추가해야 한다. `StableEfficientSorter` 라고 이름도 변경하게 될 것이다.

만약 프로토콜이 메소드 요구사항 뿐이라면, 구현 상세에 따라 코드의 동작을 완전히 변경될 수 있기 때문에 완전한 제네릭 함수로 작성하기 어렵다. 프로토콜은 의미론적 요구사항을 설명하기 위해 사용될 수도 있다. 이 때문에 스위프트는 자동적으로 타입이 프로토콜을 채택하도록 하지 않는다. 코드를 작성할 때, 어떠한 의미론적 요구사항이 프로토콜에 중요한지 고려하며 문서화할 필요가 있다.

기타 외부 참고 자료: https://oleb.net/blog/2016/12/protocols-have-semantics/

### Protocol syntax

#### Implementing protocols
#### Extending protocols


## 3.2 Behind the scenes of protocols
프로토콜의 엣지 케이스와 성능 고려를 위해서는 스위프트의 내부 동작을 살펴볼 필요가 있다.

### Static and dynamic dispatch
구체적으로는, 함수가 호출될 때 어떤 일이 발생하는지 이해할 필요가 있다. 런타임에 스위프트는 함수 명을 검색하여 그 주소값으로 점프하고, 코드를 실행한다. 

함수를 저장하고 호출하는 데에 두가지 주요 매커니즘이 있다: 정적 및 동적 디스패치. 정적 디스패치는 구조체에 선언된 전역 함수와 메소드나 `final` 클래스의 메소드와 같이, 함수가 절대 변하지 않을 때 일어난다. 

이 경우에, 함수 오버라이딩이 발생하지 않아 컴파일러는 함수의 주소를 하드코드할 수 있고 함수가 참조될 때마다 점프할 수 있다.

> **Note**: 메소드 디스패치 이외에, 스위프트가 광범위하게 사용하는 inlining 이라고 불리는 기술이 있다. 인라이닝은 컴파일 타임에 함수 호출을 함수의 전체 몸체로 대체한다. 함수를 호출하는 가장 빠른 방법이지만, 정적 디스패치와 특정 상황에서만 가능하다.

상속과 프로토콜을 추가할 때, 상황은 더 복잡해진다. `final` 클래스가 아닌 클래스의 인스턴스에서 호출된 메소드는 여러 장소에 선언될 수 있다. 클래스 내부, 부모 클래스, 익스텐션이나 프로토콜 익스텐션에 선언될 수 있다. 이는 곧 컴파일러가 함수의 정확한 주소를 미리 알 수 없음을 의미한다. 대신에 목격자(witness) 테이블이라고 불리는 것을 사용한다. (v-table 혹은 가상 테이블이라고 불리기도 한다.)

컴파일러는 코드를 살펴보며 각 클래스 마다의 테이블을 생성한다. 이 테이블은 두개의 열로 구성된다: 하나는 테이블 내부의 오프셋을 위한 열이고, 다른 하나는 그 오프셋에 있는 함수를 위한 열이다. 클래스의 각 함수는 작업 메모리에 저장되는 테이블에 저장된다. 서브클래스는 부모의 테이블을 복사하여 메소드의 행을 오버라이드 할 것으로 대체한다. 목격자 테이블이 만들어지고, 스위프트는 런타임에 이 테이블을 사용할 수 있다. 메소드를 호출하는 상황에서 스위프트는 테이블 내의 해당 메소드로의 오프셋이 어떤 건지 안다.

이것은 상속, 다형성, 프로토콜과 같은 특징을 허용하면서 같은 이름의 메소드 구현을 동적으로 변경할 수 있도록 해준다. 하지만 비용이 발생하며, 테이블 행의 함수를 호출하는 것은 매 함호 호출마다 상수 시간의 오버헤드가 더해진다. 또한, 인라이닝과 기타 컴파일러 최적화를 제한하며, 정적 디스패치보다 동적 디스패치를 느리게 만든다. 

### Dispatch in protocols
상속은 동적 디스패치를 요구하여 컴파일러를 복잡하게 만든다고 하였다. 프로토콜 또한 상속을 지원한다. 그 밖에 여러 클래스와 구조체는 동일한 프로토콜을 채택하여 동일한 메소드를 구현할 수 있다. 그리고 위 예제에서 다뤘듯이 동일한 방식으로 사용된다. 만약 인스턴스의 타입으로서 프로토콜을 사용한다면, 스위프트는 `Localizable` 인스턴스가 `UILabel` 일지 `Text` 일지 미리 알기 어렵다. 그래서 동적 메소드 디스패치가 필요하다.

프로토콜 메소드를 파견하는 것은 클래스의 동작과 유사하다. 프로토콜을 구현하는 모든 타입은 고유의 프로토콜 목격자 테이블을 갖는다. 테이블은 다시 두개의 열을 갖고 하나는 함수, 다른 하나는 함수의 오프셋이다. 프로토콜의 각 멤버(메소드나 변수)는 테이블 내의 각각의 행을 갖는다. 그런 다음 이 테이블은 각 인스턴스와 함께 저장된다. 그리고 스위프트는 런타임에 프로토콜 목격자 테이블에서 올바른 함수를 찾고 호출할 수 있다. 만약 클래스 인스턴스를 사용한다면, 스위프트는 클래스와 프로토콜 목격자 테이블 두가지에서 함수를 살펴볼 수 있고, 동적으로 올바른 구현을 찾게 된다.

#### Dealing with extensions
프로토콜의 디폴트 메소드를 구현하기 위해 익스텐션을 정의할 때, 그 익스텐션은 프로토콜 테이블에 저장될까 아니면 구현하는 인스턴스의 테이블에 저장될까? 만약 프로토콜의 요구사항이 아닌 메소드를 위해 프로토콜 익스텐션을 추가했다면 어떨까? 정적 디스패치와 동적 디스패치를 이해하는 것이 이 질문의 답을 하는데 도움이 될 것이다.

우선, 디폴트 메소드 구현을 제공하기 위해 프로토콜을 확장한 경우를 보자. 
```swift
protocol Greetable {
	func greet() -> String
}

extension Greetable {
	func greet() -> String {
		return "Hello"
	}
}
```

다음, 프로토콜을 구현하는 구조체를 생성하자:
```swift
struct GermanGreeter: Greetable {
}
```

그리고, 인스턴스를 생성하여 프로토콜 메소드를 호출하자:
```swift
let greeter = GermanGreeter()
print(greeter.greet())
```

디폴트 `greet` 구현은 프로토콜을 채택하는 모든 타입에 복사되고 그들의 프로토콜 목격자 테이블에 추가되기 때문에, "Hello" 가 출력된다. 프로토콜 자체는 테이블을 갖지 않고 구체 타입만 갖게 됨을 주의하자. 

잘못된 인사법이므로, `GermanGreeter` 내부에 독일어로 번역하여 이 메소드를 구현하자.
```swift
func greet() -> String{
	return "Hallo"
}
```

새로운 구현이 프로토콜 목격자 테이블에 있는 익스텐션 메소드를 대체하기 때문에 "Hallo" 가 출력된다. 클래스에서 메소드를 오버라이드할 때에도 동일한 동작이 일어난다. 

다음은 예상치 못한 상황을 만들어보자. 프로토콜 익스텐션에 새로운 메소드를 추가하자:
```Swift
func leave() -> String{
	return "GoodBye"
}
```

이 함수는 프로토콜 익스텐션에 존재하지만 요구사항은 아니다. 하지만, 여전히 이를 구현하는 모든 타입은 이 메소드에 접근할 수 있다. 

다시 이를 번역하여 `GermanGreeter` 에 새로운 메소드를 추가해보자.
```swift
func leave() -> String{
	return "Tschüss"
}
```

이전과 같이 실행하면 새로운 메소드가 호출된다. 하지만, `greeter` 의 선언을 프로토콜을 사용하도록 변경하면:
```swift
let greeter: Greetable = GermanGreeter()
```

`greet`은 여전히 "Hallo" 를 출력하지만, `leave` 는 "Goodbye" 가 출력된다!?

스위프트는 구조체 내부에 선언된 함수를 완전히 건너뛰고 프로토콜 익스텐셩에 있는 함수를 호출한다. 이는 변수가 선언된 타입에 의존하여 함수를 호출하기 때문으로, 다형성이 동작하지 않음을 의미한다. 

사실 인스텐션 메소드는 전적으로 정적 디스패치에 의존한다. `leave` 를 호출하는 데 관여하는 테이블은 없다. 스위프트는 변수의 타입에서 정적으로 호출한다. `greet` 은 프로토콜 요구사항에 추가하여, 스위프트가 해당 메소드를 위한 프로토콜 목격자 테이블을 생성하도록 했고, 동적 디스패치를 가능케 했기 때문에, 예상대로 동작한 것이다.

## 3.3 Protocols and the type system
### Existentials
```swift
let greeter: Greetable = GermanGreeter()
```
이 코드에서 `Greetable` 을 사용하는 것과 `Int` 와 같은 구체 타입을 사용하는 데는 큰 차이가 있다. `Greetable` 은 보통 타입 처럼 보이고 행동하지만 실존의(existential) 타입이라고 불린다. 구체 타입의 플레이스홀더로 생각할 수 있다. 컴파일러는 이 것을 "이 프로토콜을 채택하는 어떤 타입이 존재한다"로 번역한다. 실존의 타입은 프로토콜을 메소드 파라미터, 배열 인자, 변수 그리고 다른 자료 구조의 타입으로 사용할 수 있도록 해준다.

### Using protocols as types
앞서 다음과 같이 프로토콜을 타입으로서 사용하는 예제를 보았다:
```swift
func greet(with greeter: Greeter) -> Void 
let englishGreeter: Greeter = EnglishGreeter() 
let allGreeters: [Greeter] = [englishGreeter]
```

또한 덜 알려졌지만 유용한 프로토콜 사용 방법이 있다. 예를 들어, `&` 연산자를 사용하여 여러 타입이 하나의 타입으로 조합할 수 있다:
```swift
func localizedGreet(with greeter: Greeter & Localizable)
```

구조체 타입과 프로토콜을 조합(`Date & Cadable`) 할 수도 있고, 클래스 타입과 프로토콜을 조합(`UITableViewCell & Selectable`)하거나 여러 프로토콜들을 위와 같이 조합할 수 있다.

하지만, non-nominal 타입이라 불리는, 조합된 타입은 변수의 타입으로서만 사용할 수 있다. 예를 들어, `Greeter & Localizable` 의 익스텐션은 정의할 수 없다. 다른 방법으로는 가능하다.

예를 들어, 프로토콜을 채택하는 클래스의 모든 서브클래스의 익스텐션을 정의할 수 있다.
```swift
extension UITableViewDelegate where Self: UIViewController {
	func showAlertForSelectedCell(at index: IndexPath) {
	}
}
```

여기서 `UITableViewDelegate` 를 채택하는 모든 `UIViewConroller` 는 자동적으로 `showAlertForSelectedCell` 의 구현을 갖게 된다.

또한 제네릭 파라미터가 프로토콜을 채택하는 제네릭 타입을 확장할 수 있다:
```swift
extension Array where Element: Greetable {
	var allGreetings: String {
		self.map { $0.greet() }.joined()
	}
}
```

더 나아가 제네릭 파라미터가 프로토콜을 채택하는 제네릭 타입이 프로토콜을 채택하도록 할 수 있다.
```swift
extension Array: Localizable where Element: Localizable {
	static var supportedLanguages: [Language] {
		Element.supportedLanguages
	}
}
```

위 익스텐션은 `Element` 타입이 `Localizable` 인 경우에 모든 배열을 `Localizable` 로 만든다. 정확히 이방법으로, 스위프트가 `Codable` 항목들의 배열을 `Codable` 을 채택하게 하고, `Equatable` 항목들의 배열을 `Equatable` 을 채택하게 만든다.

## 3.4 Synthesized protocol conformance
`Codable` 과 같은 프로토콜을 채택하기만 해도 동작이 가능해지는 경우를 경험했을 것이다. 이는 스위프트가 합성된 프로토콜 구현을 생성할 때 발생한다. `Equatable`, `Hashable`, `Comparable`, 그리고 `Codable` 프로토콜인 `Encodable` 과 `Decodable` 이 그에 해당한다. 

각 프로토콜마다의 제한이 있긴 하다. 대게, 스위프트는 모든 속성이 그 프로토콜을 따르는 경우에 순응을 생성할 수 있다. 예를 들어 `Hashable` 의 경우에, 스위프트가 요구되는 메소드를 합성하기 위해서는 모든 속성이 해싱이 가능해야 한다. 

``` swift
struct User: Hashable {
	let name: String
	let email: String
	let id: UUID
}
```

## 3.5 Protocol-oriented programming
실습 ㄱㄱ

## 3.6 Key points
- 프로토콜은 구체적인 타입으로부터 정보를 추상화할 수 있게 해주어, 같은 장소에서 여러 타입을 사용할 수 있도록 해준다.
- 존재하는 타입을 확장하여 프로토콜을 채택하도록 할 수 있고, 특정한 서브타입으로 채택을 제한할 수도 있다.
- 프로토콜은 함수 호출을 위해 동적 디스패치를 사용한다. 단, 프로토콜의 요구사항이 아닌 익스텐션에만 정의된 메소드의 경우는 제외한다.
- 스위프트는 `Equatable`, `Hashable`, `Comparable`, `Codable` (`Encodable`, `Decodable`) 을 위한 프로토콜 순응을 합성한다.
- 의존 역전은 구체적인 구현체 대신에 프로토콜 타입으로 의존을 선언하여 코드를 유연하게 만드는 기술이다.
- 의존 역전과 함께 의존 주입을 통하면 코드의 테스트 용이성이 높아진다.
- 복잡한 클래스에 유연성을 주기 위해 델리게이트를 추가하자. 강한 참조 사이클을 유념하며 이를 피하기 위해 약한 참조를 활용해라.